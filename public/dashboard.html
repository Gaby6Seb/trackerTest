<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Splashin' Live Dashboard</title>

  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="/style.css">
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.3.2/socket.io.js"></script>
  <!-- OneSignal SDK -->
  <script src="https://cdn.onesignal.com/sdks/web/v16/OneSignalSDK.page.js" defer></script>
</head>
<body>
  <div class="header">
    <div class="header-content">
        <h1>Splashin' Live Dashboard</h1>
        <p class="subtitle">Connecting...</p>
    </div>
    <div class="user-info">
        <button id="notification-btn" style="display: none;">üîî</button>
        <span id="display-name"></span>
        <button id="logout-btn">Logout</button>
    </div>
  </div>
  <div id="map"></div>
  <div id="controls-container">
    <div id="search-container">
        <input type="text" id="player-search" placeholder="Search names or teams (e.g., John, Blue Team)...">
        <button id="clear-search-btn">&times;</button>
    </div>
    <div id="filter-toggles">
      <label for="show-all-toggle">
        <input type="checkbox" id="show-all-toggle">
        Show All Players
      </label>
    </div>
    <div id="safezone-container" class="minimized">
        <h2 id="safezone-header">
            Players in Safe Zone
            <span id="safezone-toggle-icon">+</span>
        </h2>
        <ul id="safezone-list"></ul>
    </div>
    <div id="stealth-container" class="minimized">
        <h2 id="stealth-header">
            Stealthed Players
            <span id="stealth-toggle-icon">+</span>
        </h2>
        <ul id="stealth-list"></ul>
    </div>
    <div id="not-located-container" class="minimized">
        <h2 id="not-located-header">
            Players Not on Map
            <span id="toggle-icon">+</span>
        </h2>
        <ul id="not-located-list"></ul>
    </div>
  </div>

  <!-- Notification Modal -->
  <div id="notification-modal-overlay" class="modal-overlay" style="display: none;">
    <div id="notification-modal" class="modal-content">
        <button id="modal-close-btn" class="modal-close-btn">&times;</button>
        
        <div id="player-selection-step">
            <h2>Who are you?</h2>
            <p>Select your name from the list to enable notifications.</p>
            <ul id="teammate-list"></ul>
        </div>
        
        <div id="notification-settings-step" style="display: none;">
            <h2>Notification Settings for <span id="my-player-name"></span></h2>
            <p><a href="#" id="change-player-link">Not you? Change player.</a></p>
            
            <div class="setting-row master-toggle">
                <label>Manage Subscription</label>
                <div class='onesignal-customlink-container'></div>
            </div>

            <div class="setting-row master-toggle">
                <label for="enable-notifications">Enable Alert Preferences</label>
                <input type="checkbox" id="enable-notifications" class="toggle-switch">
            </div>

            <fieldset id="notification-fieldset">
                <div class="setting-row">
                    <label for="proximity-radius">Proximity Alert Radius (miles)</label>
                    <div class="range-container">
                        <input type="range" id="proximity-radius" min="0" max="10" step="0.5" value="0">
                        <span id="proximity-value">Off</span>
                    </div>
                </div>

                <div class="setting-row">
                    <label for="ghost-radius">"Ghost" Alert Radius (miles)</label>
                    <div class="range-container">
                        <input type="range" id="ghost-radius" min="0" max="10" step="0.5" value="0">
                        <span id="ghost-value">Off</span>
                    </div>
                    <label class="sub-label">
                      <input type="checkbox" id="ghost-worldwide"> No Range Limit (Worldwide)
                    </label>
                </div>
            </fieldset>
            
            <button id="save-settings-btn">Save Alert Preferences</button>
            <button id="test-notification-btn" style="margin-top: 10px;">Send Test Notification</button>
        </div>
    </div>
  </div>

<script>
// --- OneSignal Initialization ---
async function initializeOneSignal() {
    if (!window.OneSignal) {
        console.error("OneSignal SDK not loaded.");
        document.getElementById('notification-btn').style.display = 'none';
        return;
    }
    try {
        await OneSignal.init({
            appId: "95e17686-f5df-4181-a59a-f89457df2973",
            allowLocalhostAsSecureOrigin: true,
            serviceWorkerPath: '/OneSignalSDKWorker.js',
        });
        console.log("OneSignal SDK initialized successfully.");
        if (!OneSignal.Notifications.isPushSupported()) {
            console.warn("Push notifications are not supported by this browser.");
            document.getElementById('notification-btn').style.display = 'none';
            return;
        }
        console.log("Push notifications are supported.");
        const updateSubscriptionUI = () => {
            if (document.getElementById('notification-modal-overlay').style.display === 'flex') {
                checkSubscriptionStatus();
            }
        };
        OneSignal.User.PushSubscription.addEventListener('change', updateSubscriptionUI);
        OneSignal.Notifications.addEventListener('permissionChange', updateSubscriptionUI);
        await checkSubscriptionStatus();
    } catch (error) {
        console.error("OneSignal SDK initialization failed:", error);
        document.getElementById('notification-btn').style.display = 'none';
    }
}
window.OneSignalDeferred = window.OneSignalDeferred || [];
window.OneSignalDeferred.push(initializeOneSignal);

// --- Login Authentication Guard ---
const username = localStorage.getItem('username');
const isMaster = localStorage.getItem('isMaster') === 'true';
const displayName = localStorage.getItem('displayName');
const canSeeAllPlayers = localStorage.getItem('canSeeAllPlayers') === 'true';
const canUseNotifications = localStorage.getItem('canUseNotifications') === 'true';
if (!username) {
    window.location.href = '/';
}
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('display-name').textContent = displayName || username;
    if (isMaster || canSeeAllPlayers) {
        document.getElementById('filter-toggles').style.display = 'flex';
    } else {
        document.getElementById('filter-toggles').style.display = 'none';
    }
    // Show notification bell only if user is authorized AND push is supported
    if (canUseNotifications && OneSignal.Notifications.isPushSupported()) {
         document.getElementById('notification-btn').style.display = 'block';
    }
    document.getElementById('logout-btn').addEventListener('click', async () => {
        const token = localStorage.getItem('authToken');
        if (token) {
            try {
                await fetch('/logout', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token }) });
            } catch (err) { console.error("Failed to notify server of logout:", err); }
        }
        if (window.OneSignal) await window.OneSignal.logout();
        localStorage.clear();
        socket.disconnect();
        window.location.href = '/';
    });
});

// --- Map & Socket Logic ---
const map = L.map('map').setView([33.04, -97.02], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);
const markers = L.markerClusterGroup({ maxClusterRadius: 60, disableClusteringAtZoom: 14, chunkedLoading: true, spiderfyOnMaxZoom: true });
map.addLayer(markers);
const socket = io();
let currentMarkers = {};
let allPlayersWithLocation = [];
let allPanelData = {};
let showAllPlayers = false;
let initialMapLoad = true;
let timerUpdateInterval = null;

// --- FIXED createAvatarIcon FUNCTION ---
const createAvatarIcon = (color, avatarUrl, role, isSafeZone, isLastKnown, isStealthed, isImmune) => { // Added isImmune to params
    const baseClass = avatarUrl ? 'marker-pin-avatar' : 'marker-pin';
    const safeZoneClass = isSafeZone ? 'safezone-marker' : '';
    const stealthedClass = isStealthed ? 'stealthed-marker' : '';
    const lastKnownClass = (isLastKnown && !isImmune) ? 'last-known-marker' : '';
    const avatarImage = avatarUrl ? `<img src="${avatarUrl}" class="marker-avatar-image" alt="player avatar"/>` : '';
    let pinStyles = `background-color: ${color || '#3388ff'};`;
    if (!avatarUrl) {
        pinStyles += `border-color: ${color || '#3388ff'};`;
    }
    const pulseHtml = !isLastKnown ? `<div class="marker-pulse-effect ${role}-pulse"></div>` : '';
    const shieldHtml = isImmune ? '<div class="marker-shield">üõ°Ô∏è</div>' : ''; // Shield logic is correct

    // Combine all HTML parts into the marker container
    const markerHtml = `
        <div class="marker-container ${role}-marker ${safeZoneClass} ${stealthedClass} ${lastKnownClass}">
            <div class="${baseClass}" style="${pinStyles}">
                ${avatarImage}
                ${shieldHtml} 
            </div>
            ${pulseHtml}
        </div>
    `;

    const iconSize = avatarUrl ? [40, 52] : [30, 42];
    const iconAnchor = avatarUrl ? [20, 52] : [15, 42];
    return L.divIcon({ className: 'custom-div-icon', html: markerHtml, iconSize, iconAnchor });
};

socket.on('locationUpdate', (data) => {
    document.querySelector('.subtitle').textContent = 'Live';
    allPlayersWithLocation = [
        ...data.located.map(p => ({ ...p, statusType: 'located' })),
        ...data.safeZone.filter(p => p.lat && p.lng).map(p => ({ ...p, statusType: 'safeZone' })),
        ...data.stealthed.filter(p => p.lat && p.lng).map(p => ({ ...p, statusType: 'stealthed' })),
    ];
    allPanelData = data;
    const listMapping = [
        { containerId: 'safezone-container', listId: 'safezone-list', data: data.safeZone },
        { containerId: 'stealth-container', listId: 'stealth-list', data: data.stealthed },
        { containerId: 'not-located-container', listId: 'not-located-list', data: data.notLocated, reasonKey: 'reason' }
    ];
    listMapping.forEach(({ containerId, listId, data: players, reasonKey }) => {
        const container = document.getElementById(containerId);
        const list = document.getElementById(listId);
        list.innerHTML = '';
        if (players && players.length > 0) {
            container.style.display = 'flex';
            players.sort((a, b) => a.firstName.localeCompare(b.firstName)).forEach(player => {
                const listItem = document.createElement('li');
                listItem.dataset.uid = player.u;
                let details = reasonKey && player[reasonKey] ? ` - ${player[reasonKey]}` : '';
                if (player.lat && player.lng) {
                    listItem.classList.add('clickable-list-item');
                    listItem.onclick = () => panToLastLocation(player.lat, player.lng);
                }
                let timerHtml = '';
                if (containerId === 'stealth-container' && player.stealthExpiresAt) {
                    timerHtml = `<span class="stealth-timer" data-expires-at="${player.stealthExpiresAt}"></span>`;
                }
                listItem.innerHTML = `<span style="color:${player.teamColor || '#999999'}; font-weight: bold;">${player.firstName} ${player.lastName || ''}</span> (${player.teamName || 'N/A'})${details}${timerHtml}`;
                list.appendChild(listItem);
            });
        } else {
            container.style.display = 'none';
        }
    });
    startTimerUpdates();
    filterMarkers(document.getElementById('player-search').value, initialMapLoad);
    if (initialMapLoad) initialMapLoad = false;
});

// --- FIXED filterMarkers FUNCTION ---
function filterMarkers(searchTerm, shouldFitBounds = false) {
    markers.clearLayers();
    const searchTerms = searchTerm.toLowerCase().split(',').map(t => t.trim()).filter(Boolean);
    const foundPlayerCoords = [];
    const updatedUids = new Set();
    allPlayersWithLocation.forEach(user => {
        const { u, lat, lng, firstName, lastName, teamName, teamColor, avatarUrl, role, speed, batteryLevel, isCharging, updatedAt, accuracy, isSafeZone, statusType, isImmune } = user;
        const isNeutral = role !== 'teammate' && role !== 'target';
        const shouldDisplay = showAllPlayers || !isNeutral;
        if (!shouldDisplay) return;
        const fullName = `${firstName || ''} ${lastName || ''}`.toLowerCase();
        const fullTeamName = (teamName || '').toLowerCase();
        const isMatch = searchTerms.length === 0 || searchTerms.some(term => fullName.includes(term) || fullTeamName.includes(term));
        if (isMatch) {
            updatedUids.add(u);
            foundPlayerCoords.push(L.latLng(lat, lng));
            let popupContent;
            const isLastKnown = statusType === 'safeZone' || statusType === 'stealthed';
            if (isLastKnown) {
                popupContent = `<div class="popup-header" style="background-color: ${teamColor || '#999'};"><span>${firstName} ${lastName}</span></div><div class="popup-body"><strong>Status:</strong> ${statusType === 'safeZone' ? 'In Safe Zone' : 'Stealthed'}<br><strong>Last Known Location</strong></div><div class="popup-footer">Last update: ${updatedAt ? new Date(updatedAt).toLocaleTimeString() : 'N/A'}</div>`;
            } else {
                const batteryIcon = isCharging ? '‚ö°' : 'üîã';
                const batteryStatus = `${(batteryLevel * 100).toFixed(0)}% ${batteryIcon}`;
                let roleLabel = '';
                if (role === 'target') roleLabel = '<span class="role-label target">TARGET</span>';
                else if (role === 'teammate') roleLabel = '<span class="role-label teammate">TEAMMATE</span>';
                const immunityStatus = isImmune ? '<strong>Status:</strong> <span style="color: #3498db;">Immune</span><br>' : '';
                popupContent = `<div class="popup-header" style="background-color: ${teamColor || '#3388ff'};"><span>${firstName} ${lastName}</span>${roleLabel}</div><div class="popup-body">${immunityStatus}<strong>Team:</strong> ${teamName || 'N/A'}<br><strong>Speed:</strong> ${speed.toFixed(1)} m/s<br><strong>Accuracy:</strong> ${accuracy.toFixed(0)} m<br><strong>Battery:</strong> ${batteryStatus}<br></div><div class="popup-actions"><button class="popup-directions-btn" onclick="getDirections(this)" data-lat="${lat}" data-lng="${lng}">Get Directions</button></div><div class="popup-footer">Last update: ${updatedAt ? new Date(updatedAt).toLocaleTimeString() : 'N/A'}</div>`;
            }
            const isStealthed = statusType === 'stealthed';
            // Pass isImmune to the icon creator
            const playerIcon = createAvatarIcon(teamColor || '#3388ff', avatarUrl, role, isSafeZone, isLastKnown, isStealthed, isImmune);
            if (currentMarkers[u]) {
                currentMarkers[u].setLatLng([lat, lng]).setIcon(playerIcon).setPopupContent(popupContent);
            } else {
                currentMarkers[u] = L.marker([lat, lng], { icon: playerIcon }).bindPopup(popupContent);
            }
            markers.addLayer(currentMarkers[u]);
        }
    });
    const currentlyTracked = markers.getLayers().length;
    const subtitleEl = document.querySelector('.subtitle');
    if (subtitleEl.textContent !== 'Connecting...' && subtitleEl.textContent !== 'Authenticating...') {
        subtitleEl.textContent = `Tracking ${currentlyTracked} players on map.`;
    }
    if (markers.getLayers().length === 0 && searchTerms.length > 0) {
        findAndExpandList(searchTerms[0]);
    } else {
        document.querySelectorAll('li.highlighted').forEach(el => el.classList.remove('highlighted'));
    }
    if (shouldFitBounds) {
        if (searchTerms.length > 0 && foundPlayerCoords.length > 0) {
            if (foundPlayerCoords.length > 1) {
                map.fitBounds(L.latLngBounds(foundPlayerCoords), { padding: [50, 50], maxZoom: 16 });
            } else {
                map.setView(foundPlayerCoords[0], 16);
                if (updatedUids.size === 1) {
                    const singleMarker = currentMarkers[updatedUids.values().next().value];
                    if (singleMarker) singleMarker.openPopup();
                }
            }
        } else {
            const allVisibleCoords = allPlayersWithLocation
                .filter(p => showAllPlayers || p.role === 'teammate' || p.role === 'target')
                .map(p => L.latLng(p.lat, p.lng));
            if (allVisibleCoords.length > 0) {
                map.fitBounds(L.latLngBounds(allVisibleCoords), { padding: [50, 50] });
            }
        }
    }
    for (const uid in currentMarkers) {
        if (!updatedUids.has(uid)) delete currentMarkers[uid];
    }
}

// --- All remaining functions are correct and unchanged ---
// (handleSubscribeClick, checkSubscriptionStatus, setupNotificationModal, etc.)
async function handleSubscribeClick() { if (!window.OneSignal) return; try { const permission = await OneSignal.Notifications.permission; if (permission === 'denied') { alert('Notifications are blocked. Please enable them in your browser settings and try again.'); return; } await OneSignal.User.PushSubscription.optIn(); console.log('User successfully opted in.'); await checkSubscriptionStatus(); } catch (error) { console.error('Subscription error:', error); } }
async function handleUnsubscribeClick() { if (!window.OneSignal) return; try { await OneSignal.User.PushSubscription.optOut(); console.log('User successfully opted out.'); await checkSubscriptionStatus(); } catch (error) { console.error('Unsubscription error:', error); } }
async function checkSubscriptionStatus() { if (!window.OneSignal) return; const subscribeContainer = document.querySelector('.onesignal-customlink-container'); subscribeContainer.innerHTML = ''; const button = document.createElement('button'); try { const permission = await OneSignal.Notifications.permission; if (permission === 'denied') { button.textContent = 'Enable Notifications (Blocked)'; button.onclick = () => alert('Notifications are blocked. Please enable them in your browser settings and try again.'); button.className = 'subscribe-btn disabled'; } else if (OneSignal.User && OneSignal.User.PushSubscription) { const isSubscribed = OneSignal.User.PushSubscription.optedIn; button.textContent = isSubscribed ? 'Unsubscribe from Push Notifications' : 'Subscribe to Push Notifications'; button.onclick = isSubscribed ? handleUnsubscribeClick : handleSubscribeClick; button.className = isSubscribed ? 'unsubscribe-btn' : 'subscribe-btn'; } else { button.textContent = 'Push Notifications Not Supported'; button.disabled = true; button.className = 'subscribe-btn disabled'; } subscribeContainer.appendChild(button); } catch (error) { console.error('Error checking subscription status:', error); button.textContent = 'Notifications Unavailable'; button.disabled = true; button.className = 'subscribe-btn disabled'; subscribeContainer.appendChild(button); } }
function setupNotificationModal(teammates) { const modalOverlay = document.getElementById('notification-modal-overlay'); const openBtn = document.getElementById('notification-btn'); const closeBtn = document.getElementById('modal-close-btn'); const playerSelectionStep = document.getElementById('player-selection-step'); const settingsStep = document.getElementById('notification-settings-step'); const teammateList = document.getElementById('teammate-list'); const changePlayerLink = document.getElementById('change-player-link'); const saveBtn = document.getElementById('save-settings-btn'); const settingsTitle = settingsStep.querySelector('h2'); const testBtn = document.getElementById('test-notification-btn'); teammateList.innerHTML = ''; if (teammates && teammates.length > 0) { teammates.forEach(player => { const li = document.createElement('li'); li.textContent = player.name; li.dataset.id = player.id; li.onclick = () => { localStorage.setItem('myPlayerId', player.id); localStorage.setItem('myPlayerName', player.name); showUserSettings(player.name); }; teammateList.appendChild(li); }); } else { playerSelectionStep.querySelector('p').textContent = 'No teammates are available to select for notifications at this time.'; } const showUserSettings = (playerName) => { playerSelectionStep.style.display = 'none'; settingsStep.style.display = 'block'; settingsTitle.innerHTML = `Notification Settings for <span id="my-player-name">${playerName}</span>`; loadSettings(); checkSubscriptionStatus(); }; openBtn.onclick = () => { modalOverlay.style.display = 'flex'; const myPlayerId = localStorage.getItem('myPlayerId'); const myPlayerName = localStorage.getItem('myPlayerName'); if (myPlayerId && myPlayerName) { showUserSettings(myPlayerName); } else { playerSelectionStep.style.display = 'block'; settingsStep.style.display = 'none'; checkSubscriptionStatus(); } }; changePlayerLink.onclick = async (e) => { e.preventDefault(); if (window.OneSignal) { await window.OneSignal.logout(); console.log('Logged out of OneSignal identity.'); } localStorage.removeItem('myPlayerId'); localStorage.removeItem('myPlayerName'); playerSelectionStep.style.display = 'block'; settingsStep.style.display = 'none'; }; const closeModal = () => modalOverlay.style.display = 'none'; closeBtn.onclick = closeModal; modalOverlay.onclick = (e) => { if (e.target === modalOverlay) closeModal(); }; const enableNotifications = document.getElementById('enable-notifications'); const fieldset = document.getElementById('notification-fieldset'); const proximitySlider = document.getElementById('proximity-radius'); const proximityValue = document.getElementById('proximity-value'); const ghostSlider = document.getElementById('ghost-radius'); const ghostValue = document.getElementById('ghost-value'); const ghostWorldwide = document.getElementById('ghost-worldwide'); enableNotifications.onchange = () => { fieldset.disabled = !enableNotifications.checked; }; proximitySlider.oninput = () => { proximityValue.textContent = proximitySlider.value > 0 ? `${proximitySlider.value} mi` : 'Off'; }; ghostSlider.oninput = () => { ghostValue.textContent = ghostSlider.value > 0 ? `${ghostSlider.value} mi` : 'Off'; }; ghostWorldwide.onchange = () => { ghostSlider.disabled = ghostWorldwide.checked; ghostValue.textContent = ghostWorldwide.checked ? 'Worldwide' : (ghostSlider.value > 0 ? `${ghostSlider.value} mi` : 'Off'); }; function loadSettings() { const settings = JSON.parse(localStorage.getItem('notificationSettings')) || {}; enableNotifications.checked = settings.hasOwnProperty('enabled') ? settings.enabled : true; proximitySlider.value = settings.proximityMiles || 0; ghostSlider.value = settings.ghostMiles > 0 ? settings.ghostMiles : 0; ghostWorldwide.checked = settings.ghostMiles === -1; proximitySlider.dispatchEvent(new Event('input')); ghostSlider.dispatchEvent(new Event('input')); ghostWorldwide.dispatchEvent(new Event('change')); enableNotifications.dispatchEvent(new Event('change')); } saveBtn.onclick = async () => { const myPlayerId = localStorage.getItem('myPlayerId'); if (parseFloat(proximitySlider.value) > 0 && !myPlayerId) { alert("Please select your player profile to enable proximity alerts."); return; } const settings = { myPlayerId: myPlayerId, enabled: enableNotifications.checked, proximityMiles: parseFloat(proximitySlider.value), ghostMiles: ghostWorldwide.checked ? -1 : parseFloat(ghostSlider.value) }; localStorage.setItem('notificationSettings', JSON.stringify(settings)); socket.emit('update_notification_settings', settings); try { if (settings.myPlayerId) { console.log(`Logging into OneSignal with external_id: ${settings.myPlayerId}`); await window.OneSignal.login(settings.myPlayerId); console.log(`Successfully identified user to OneSignal.`); } else { await window.OneSignal.logout(); } } catch (error) { console.error('OneSignal login/logout error:', error); alert('Could not update your notification identity. Please try again.'); } closeModal(); alert('Alert preferences saved!'); }; testBtn.onclick = async () => { const myPlayerId = localStorage.getItem('myPlayerId'); if (!myPlayerId) { alert('Please select your player profile and save settings before sending a test.'); return; } console.log(`Requesting test notification for external_id: ${myPlayerId}`); try { const res = await fetch('/test-notification', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ externalId: myPlayerId }) }); const data = await res.json(); if (!res.ok) { throw new Error(data.message || 'Unknown server error'); } alert('‚úÖ Test notification request sent successfully!'); } catch (e) { console.error("Test notification error:", e); alert(`‚ö†Ô∏è Error sending test notification: ${e.message}`); } }; }
socket.on('disconnect', () => document.querySelector('.subtitle').textContent = 'Disconnected...');
const setupCollapsiblePanel = (headerId, containerId, iconId) => { const header = document.getElementById(headerId); const container = document.getElementById(containerId); const icon = document.getElementById(iconId); header.addEventListener('click', () => { container.classList.toggle('minimized'); icon.textContent = container.classList.contains('minimized') ? '+' : '-'; }); };
setupCollapsiblePanel('safezone-header', 'safezone-container', 'safezone-toggle-icon');
setupCollapsiblePanel('stealth-header', 'stealth-container', 'stealth-toggle-icon');
setupCollapsiblePanel('not-located-header', 'not-located-container', 'toggle-icon');
</script>
</body>
</html>







