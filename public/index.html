<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Splashin' Live Dashboard</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="/style.css">
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.3.2/socket.io.js"></script>
</head>
<body>

  <!-- (No changes to the body HTML) -->
  <div class="header">
    <h1>Splashin' Live Dashboard</h1>
    <p class="subtitle">Real-Time Player Locations</p>
  </div>
  <div id="map"></div>
  <div id="controls-container">
    <div id="search-container">
        <input type="text" id="player-search" placeholder="Search by name or team...">
    </div>
    <div id="not-located-container" class="minimized">
        <h2 id="not-located-header">
            Players Not on Map
            <span id="toggle-icon">+</span>
        </h2>
        <ul id="not-located-list"></ul>
    </div>
  </div>
  
  <script>
    // --- (No changes to the initial setup code) ---
    const map = L.map('map').setView([33.04, -97.02], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);
    const markers = L.markerClusterGroup({ maxClusterRadius: 60, disableClusteringAtZoom: 14, chunkedLoading: true, spiderfyOnMaxZoom: true });
    map.addLayer(markers);
    const socket = io();
    let currentMarkers = {};
    let allPlayerLocations = [];
    let initialMapLoad = true;
    const createAvatarIcon = (color, avatarUrl, role) => {
      const baseClass = avatarUrl ? 'marker-pin-avatar' : 'marker-pin';
      const avatarImage = avatarUrl ? `<img src="${avatarUrl}" class="marker-avatar-image" alt="player avatar"/>` : '';
      let pinStyles = `background-color: ${color || '#3388ff'};`;
      if (!avatarUrl) { pinStyles += `border-color: ${color || '#3388ff'};`; }
      const markerHtml = `<div class="marker-container ${role}-marker"><div class="${baseClass}" style="${pinStyles}">${avatarImage}</div><div class="marker-pulse-effect ${role}-pulse"></div></div>`;
      const iconSize = avatarUrl ? [40, 52] : [30, 42];
      const iconAnchor = avatarUrl ? [20, 52] : [15, 42]; 
      return L.divIcon({ className: 'custom-div-icon', html: markerHtml, iconSize: iconSize, iconAnchor: iconAnchor });
    };
    socket.on('connect', () => document.querySelector('.subtitle').textContent = 'Connected. Waiting for location data...');
    socket.on('locationUpdate', (data) => {
      allPlayerLocations = data.located;
      const notLocatedPlayers = data.notLocated;
      document.querySelector('.subtitle').textContent = `Tracking ${allPlayerLocations.length} players live.`; 
      const notLocatedList = document.getElementById('not-located-list');
      notLocatedList.innerHTML = ''; 
      if (notLocatedPlayers.length > 0) {
        notLocatedPlayers.forEach(player => {
          const listItem = document.createElement('li');
          listItem.innerHTML = `<span style="color:${player.teamColor || '#999999'}; font-weight: bold;">${player.firstName} ${player.lastName || ''}</span> (${player.teamName || 'N/A'}) - ${player.reason}`;
          notLocatedList.appendChild(listItem);
        });
        document.getElementById('not-located-container').style.display = 'block';
      } else {
        document.getElementById('not-located-container').style.display = 'none';
      }
      filterMarkers(document.getElementById('player-search').value, initialMapLoad);
      if (initialMapLoad) initialMapLoad = false;
    });
    const playerSearchInput = document.getElementById('player-search');
    playerSearchInput.addEventListener('input', (e) => { filterMarkers(e.target.value, false); });

    // --- CHANGE 1: UPDATE THE `getDirections` FUNCTION ---
    // It now accepts the button element itself and reads data attributes.
    // It also includes a helpful fallback if geolocation fails.
    function getDirections(buttonElement) {
        const destLat = buttonElement.dataset.lat;
        const destLng = buttonElement.dataset.lng;
        console.log("Get Directions button clicked. Destination:", destLat, destLng);

        if (!navigator.geolocation) {
            alert("Geolocation is not supported by your browser.");
            return;
        }

        const success = (position) => {
            const startLat = position.coords.latitude;
            const startLng = position.coords.longitude;
            // This universal HTTPS link works for both app and web
            const url = `https://www.google.com/maps/dir/?api=1&origin=${startLat},${startLng}&destination=${destLat},${destLng}`;
            window.open(url, '_blank');
        };

        const error = (err) => {
            let message = "Could not get your location.";
            switch(err.code) {
                case err.PERMISSION_DENIED: message += " Please enable location permissions for this site in your phone's settings."; break;
                case err.POSITION_UNAVAILABLE: message += " Location information is unavailable. Check your network/GPS."; break;
                case err.TIMEOUT: message += " The request to get your location timed out."; break;
            }
            alert(message);
            
            // BONUS: Offer a fallback link with only the destination
            if (confirm("Would you like to open Google Maps with just the destination set?")) {
                const fallbackUrl = `https://www.google.com/maps/dir/?api=1&destination=${destLat},${destLng}`;
                window.open(fallbackUrl, '_blank');
            }
        };

        const options = { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 };
        navigator.geolocation.getCurrentPosition(success, error, options);
    }


    function filterMarkers(searchTerm, initialLoad = false) {
        markers.clearLayers(); 
        const lowerCaseSearchTerm = searchTerm.toLowerCase();
        const foundPlayerCoords = []; 
        const updatedUids = new Set(); 
        allPlayerLocations.forEach(user => { 
            const { u, lat, lng, firstName, lastName, teamName, teamColor, avatarUrl, role, status, speed, batteryLevel, isCharging, updatedAt, accuracy, heading } = user;
            const fullName = `${firstName || ''} ${lastName || ''}`.toLowerCase();
            const fullTeamName = (teamName || '').toLowerCase();
            const isMatch = (!lowerCaseSearchTerm || fullName.includes(lowerCaseSearchTerm) || fullTeamName.includes(lowerCaseSearchTerm));
            if (isMatch) {
                updatedUids.add(u);
                foundPlayerCoords.push(L.latLng(lat, lng));
                const batteryIcon = isCharging ? 'âš¡' : 'ðŸ”‹';
                const batteryStatus = `${(batteryLevel * 100).toFixed(0)}% ${batteryIcon}`;
                let roleLabel = '';
                if (role === 'target') roleLabel = '<span class="role-label target">TARGET</span>';
                else if (role === 'teammate') roleLabel = '<span class="role-label teammate">TEAMMATE</span>';
                
                // --- CHANGE 2: MODIFY POPUP BUTTON TO USE DATA ATTRIBUTES ---
                // This is robust and handles negative coordinates correctly.
                const popupContent = `
                  <div class="popup-header" style="background-color:${teamColor || '#3388ff'};">
                    ${firstName} ${lastName || ''} ${roleLabel}
                  </div>
                  <div class="popup-body">
                    <strong>Team:</strong> ${teamName || 'N/A'}<br>
                    <strong>Status:</strong> ${status ? status.replace(/_/g, ' ') : 'unknown'}<br>
                    <strong>Speed:</strong> ${speed.toFixed(1)} mph<br>
                    <strong>Battery:</strong> ${batteryStatus}<br>
                    <strong>Accuracy:</strong> ${accuracy.toFixed(1)} m
                  </div>
                  <div class="popup-actions">
                    <button class="popup-directions-btn" 
                            data-lat="${lat}" 
                            data-lng="${lng}" 
                            onclick="getDirections(this)">
                      Get Directions
                    </button>
                  </div>
                  <div class="popup-footer">
                    Updated: ${new Date(updatedAt).toLocaleTimeString('en-US')}
                  </div>`;
                
                const playerIcon = createAvatarIcon(teamColor || '#3388ff', avatarUrl, role);
                if (currentMarkers[u]) {
                  currentMarkers[u].setLatLng([lat, lng]).setIcon(playerIcon).setPopupContent(popupContent);
                } else {
                  currentMarkers[u] = L.marker([lat, lng], { icon: playerIcon }).bindPopup(popupContent);
                }
                markers.addLayer(currentMarkers[u]);
            }
        });
        if (lowerCaseSearchTerm) {
            if (foundPlayerCoords.length > 0) {
                if (foundPlayerCoords.length === 1) { map.setView(foundPlayerCoords[0], 16); } 
                else { const bounds = L.latLngBounds(foundPlayerCoords); map.fitBounds(bounds, { padding: [50, 50] }); }
            }
        } else if (initialLoad && allPlayerLocations.length > 0) {
            const allCoords = allPlayerLocations.map(p => L.latLng(p.lat, p.lng));
            if (allCoords.length > 0) { const allBounds = L.latLngBounds(allCoords); map.fitBounds(allBounds, { padding: [50, 50] }); }
        }
        for (const uid in currentMarkers) { if (!updatedUids.has(uid)) { delete currentMarkers[uid]; } }
    }
    
    // --- (No changes to the disconnect or toggle logic) ---
    socket.on('disconnect', () => document.querySelector('.subtitle').textContent = 'Disconnected...');
    const notLocatedHeader = document.getElementById('not-located-header');
    const notLocatedContainer = document.getElementById('not-located-container');
    const toggleIcon = document.getElementById('toggle-icon');
    notLocatedHeader.addEventListener('click', () => {
        notLocatedContainer.classList.toggle('minimized');
        if (notLocatedContainer.classList.contains('minimized')) { toggleIcon.textContent = '+'; } 
        else { toggleIcon.textContent = '-'; }
    });
    // in index.html, inside the <script> tag

function getDirections(buttonElement) {
    const destLat = buttonElement.dataset.lat;
    const destLng = buttonElement.dataset.lng;
    console.log("Get Directions button clicked. Destination:", destLat, destLng);

    if (!navigator.geolocation) {
        alert("Geolocation is not supported by your browser.");
        return;
    }

    const success = (position) => {
        const startLat = position.coords.latitude;
        const startLng = position.coords.longitude;
        const url = `https://www.google.com/maps/dir/?api=1&origin=${startLat},${startLng}&destination=${destLat},${destLng}`;
        
        // CHANGE 1: Navigate the current tab. This is not blocked by pop-up blockers.
        window.location.href = url;
    };

    const error = (err) => {
        let message = "Could not get your location.";
        switch(err.code) {
            case err.PERMISSION_DENIED: message += " Please enable location permissions for this site in your phone's settings."; break;
            case err.POSITION_UNAVAILABLE: message += " Location information is unavailable. Check your network/GPS."; break;
            case err.TIMEOUT: message += " The request to get your location timed out."; break;
        }
        
        // Combine the alert and confirm into a single confirm dialog.
        // This gives it a slightly better chance of working if you must use window.open,
        // but the window.location.href below is the most reliable method.
        if (confirm(message + "\n\nWould you like to open Google Maps with just the destination set?")) {
            const fallbackUrl = `https://www.google.com/maps/dir/?api=1&destination=${destLat},${destLng}`;
            
            // CHANGE 2: Also navigate the current tab for the fallback.
            window.location.href = fallbackUrl;
        }
    };

    const options = { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 };
    navigator.geolocation.getCurrentPosition(success, error, options);
}
  </script>
</body>
</html>

